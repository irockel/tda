package de.grimmfrost.tda.parser;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import de.grimmfrost.tda.TDA;
import de.grimmfrost.tda.model.*;
import de.grimmfrost.tda.utils.DateMatcher;
import de.grimmfrost.tda.utils.IconFactory;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import de.grimmfrost.tda.utils.LogManager;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.MutableTreeNode;

/**
 * Parser for JSON thread dumps generated by jcmd.
 */
public class JCmdJSONParser extends AbstractDumpParser {
    private static final Logger LOGGER = LogManager.getLogger(JCmdJSONParser.class);
    private static final Gson gson = new Gson();
    private boolean hasMore = true;
    private int counter = 1;

    private Map threadStore;

    public JCmdJSONParser(BufferedReader bis, Map threadStore, int lineCounter, DateMatcher dm) {
        super(bis, dm);
        this.threadStore = threadStore;
    }

    @Override
    public boolean hasMoreDumps() {
        return hasMore;
    }

    @Override
    public MutableTreeNode parseNext() {
        if (!hasMore) {
            return null;
        }

        try {
            StringBuilder jsonContent = new StringBuilder();
            String line;
            while ((line = getBis().readLine()) != null) {
                jsonContent.append(line);
            }
            hasMore = false; // JSON jcmd output is typically one big dump

            JsonObject rootObj = gson.fromJson(jsonContent.toString(), JsonObject.class);
            if (rootObj == null || !rootObj.has("threadDump")) {
                return null;
            }

            JsonObject dumpObj = rootObj.getAsJsonObject("threadDump");
            String time = dumpObj.has("time") ? dumpObj.get("time").getAsString() : null;
            
            ThreadDumpInfo overallTDI = new ThreadDumpInfo("Dump No. " + counter++, 0);
            if (time != null) {
                overallTDI.setStartTime(time);
            }
            DefaultMutableTreeNode threadDump = new DefaultMutableTreeNode(overallTDI);

            Category threadsCat = new TableCategory("Threads", IconFactory.THREADS);
            DefaultMutableTreeNode catThreads = new DefaultMutableTreeNode(threadsCat);
            threadDump.add(catThreads);
            overallTDI.setThreads(threadsCat);

            if (dumpObj.has("threadContainers")) {
                JsonArray containers = dumpObj.getAsJsonArray("threadContainers");
                for (JsonElement containerEl : containers) {
                    JsonObject container = containerEl.getAsJsonObject();
                    if (container.has("threads")) {
                        JsonArray threads = container.getAsJsonArray("threads");
                        for (JsonElement threadEl : threads) {
                            JsonObject thread = threadEl.getAsJsonObject();
                            String name = thread.has("name") ? thread.get("name").getAsString() : "Unknown";
                            String tid = thread.has("tid") ? thread.get("tid").getAsString() : "";
                            
                            StringBuilder content = new StringBuilder("<body bgcolor=\"ffffff\"><pre><font size=" + TDA.getFontSizeModifier(-1) + ">");
                            String title = "\"" + name + "\" tid=" + tid;
                            content.append(title).append("\n");
                            
                            if (thread.has("stack")) {
                                JsonArray stack = thread.getAsJsonArray("stack");
                                for (JsonElement frameEl : stack) {
                                    content.append("   at ").append(frameEl.getAsString()).append("\n");
                                }
                            }
                            content.append("</pre></pre></body>");
                            
                            addToCategory(catThreads, title, null, content.toString(), 0, true);
                        }
                    }
                }
            }

            return threadDump;
        } catch (IOException e) {
            LOGGER.log(Level.SEVERE, "IO error parsing JSON thread dump", e);
            return null;
        }
    }

    @Override
    protected String[] getThreadTokens(String title) {
        String[] tokens = new String[7];
        // Minimal implementation for now, matching SunJDKParser's structure if possible
        // tokens: 0: name, 1: type, 2: prio, 3: tid, 4: nid, 5: state, 6: address
        
        for (int i = 0; i < tokens.length; i++) tokens[i] = "";
        
        if (title.startsWith("\"")) {
            int endQuote = title.indexOf("\"", 1);
            if (endQuote > 0) {
                tokens[0] = title.substring(1, endQuote);
                String rest = title.substring(endQuote + 1);
                if (rest.contains("tid=")) {
                    int tidIdx = rest.indexOf("tid=");
                    int nextSpace = rest.indexOf(" ", tidIdx);
                    if (nextSpace > tidIdx) {
                        tokens[3] = rest.substring(tidIdx + 4, nextSpace);
                    } else {
                        tokens[3] = rest.substring(tidIdx + 4);
                    }
                }
            }
        }
        
        return tokens;
    }

    @Override
    public boolean isFoundClassHistograms() {
        return false;
    }

    @Override
    public void parseLoggcFile(InputStream loggcFileStream, DefaultMutableTreeNode root) {
    }

    @Override
    public void setDumpHistogramCounter(int value) {
    }

    public static boolean checkForSupportedThreadDump(String logLine) {
        if (logLine == null) return false;
        String trimmed = logLine.trim();
        return trimmed.contains("\"threadDump\"") || trimmed.contains("threadDump");
    }
}
